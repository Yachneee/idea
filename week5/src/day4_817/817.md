# 继承

==继承是面向对象的三大特征之一==

继承可以解决编程中代码冗余问题，是实现代码重用的重要手段之一。新类可以在不增加自身代码的情况下，通过从现有类中继承其属性和方法，来实现充实自身内容，这种现象或行为就称为继承。此时新类称为子类，现有类称为父类。

Java类中只支持单继承，即一个类只能有一个直接父类。

类与类之间有三种关系，分别是"is a"，"use a"，"has a"，继承表达的是"is a"的关系，如Dog is a Pet.

继承的语法规则如下：

```java
[访问修饰符] class 子类名 extends 父类名{
    子类成员变量
    子类成员方法
}
```

Java中继承的一些概念：

1. 子类可以继承父类的非私有属性和方法，从而可以使用父类的非私有属性和方法；
2. 子类可以添加添加自己的属性和方法，从而达到对父类的扩展；
3. 子类的构造方法可以调用父类的构造方法。在子类的构造方法中使用super关键字可以调用父类的构造方法，从而初始化父类的属性；
   - 如果父类没有写构造方法，子类可以不用调用父类的构造；
   - 如果父类有
4. Object类是所有类的根类。每个类都是Object类的子类，因此可以使用Object类中定义的一些通用方法，如`equals()`、`hashCode()`、`toString()`等。
5. Java中的==类==只支持单一继承，每个类只能有一个直接父类；
6. 子类可以成为其它类的父类，从而建立多级继承关系。但是，过多的继承可能会导致代码难以理解和维护。

<img src="https://gitee.com/Yachnee/images/raw/master/images/image-20230817224503729.png" alt="image-20230817224503729" style="zoom: 67%;" />

> 现有类称为父类、超类、基类，新类称为子类、扩展类

### 使用super关键字调用父类成员

访问直接父类中被隐藏的内容，进一步提高代码的重用性和灵活性。

super关键字不仅可以访问父类的构造方法，还可以访问父类的成员，包括父类的字段、普通方法等。

通过super访问父类成员语法规则如下：

- 调用父类构造方法：`super([实参列表]);`
- 调用父类属性和方法：`super.<父类字段名/方法名>`

1. super只能出现在子类（子类的实例方法或构造方法）中；
2. super用于访问父类成员，如：父类的属性、方法、构造方法；
3. 具有访问权限限制，如无法通过super访问父类的private成员；
4. ==super用在子类构造函数中时，必须是子类构造函数的第一句==。

### 方法重写

在子类中可以根据需求对从父类继承的方法进行重新编写，这称为方法的重写或方法的覆盖（overriding）。方法重写必须满足如下要求：

- 在继承关系中
- 重写方法与被重写方法必须有相同的方法名称
- 重写方法与被重写方法必须有相同的参数列表
- 重写方法的返回值类型必须与被重写方法的返回值类型相同或是其子类
- 重写方法不能缩小被重写方法的访问权限
- 不能用子类的非静态方法重写（覆盖）父类的静态方法，负责编译报错
- 不能重写父类中的最终方法
- 不能用子类的静态方法重写父类的实例方法，父类的实例方法如果要扩展内容，应该用子类的实例方法重写

==方法重载和方法重写的区别 ：==

- 方法重载：
  - 同一个类
  - 方法名相同
  - 参数列表不同（类型、数量、顺序不同）
- 方法重写：
  - 发生在继承关系中
  - 不同类
  - 方法名相同
  - 参数列表相同
  - 返回值类型一致（与父类相同或是其子类）
  - 访问修饰符权限变大/相同
  - 抛出异常缩小

### 方法隐藏

父类和子类拥有相同名字的属性或方法（方法隐藏只有一种形式，就是父类和子类存在签名相同的静态方法）时，父类的同名的属性或方法形式上不见了，实际还是存在的

隐藏是对于静态方法和成员变量（静态变量和实例变量）而言的：

- 当发生隐藏时，声明类型是什么，就调用类的方法，而不会发生动态绑定
- 属性只能被隐藏，不能被覆盖
- 变量可以交叉隐藏，子类实例变量/静态变量可以隐藏父类的实例/静态变量
- 不能用子类的静态方法隐藏父类中的非静态方法，否则编译报错

### ==子类实例化过程==

`A extends B`

1. 先有父类再有子类
   - 加载类A时，要先看类B是否被加载了（类B是否第一次使用）
   - 如果是第一次使用类B则先加载类B到内存，进行静态初始化（static变量，static初始化器<clinit>）,此时类B被加载到了内存中
     - 初始化静态变量、按顺序执行静态代码块和赋值语句等
   - 然后加载子类A，进行静态初始化（static变量，static初始化器），此时类A也被加载到内存中
     - 初始化静态变量、按顺序执行静态代码块和赋值语句等
       - 类只有在第一次使用时进行加载及静态初始化，静态代码块、赋值等（按顺序）
2. 实例化（new对象）A：先创建父类对象再创建子类对象
   - 类B的实例初始化（实例初始化器），此时父类对象就创建完成
     - 调用父类构造方法，分配新对象的空间,并进行默认的初始化、按顺序执行实例代码块和赋值语句等
   - 类A的实例初始化（实例初始化器），此时子类对象就创建完成
     - 调用子类构造方法，分配新对象的空间,并进行默认的初始化、按顺序执行实例代码块和赋值语句等
   - 执行子类构造方法
     - 若父类有写(有参)构造，此时必须用super()调用父类构造，执行父类构造，再返回子类构造方法继续执行后面代码。
     - 若父类没有写构造，子类可以不用写super()调用父类构造（自动调用父类默认的无参构造），直接执行子类构造方法体

注意：

> 若在父类的静态代码块、实例代码块、构造方法等执行中调用被重写的方法时调用的是子类的该方法（其中变量值是执行时子类相应变量当时的值）
>
> 调用隐藏的方法，执行的还是父类的方法

拓展：

> 方法区是在堆里开辟的一块很小的空间
>
> `getClass()`获取类别
>
> idea中长按`ctrl`+单击（鼠标左键）`方法`可以跳转方法声明处
