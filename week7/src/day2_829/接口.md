# 接口

### 概念

接口提供一种约定，使得实现接口的类在形式上保持一致。

如果抽象类中所有的方法都是抽象方法，就可以使用Java提供的接口来表示。

#### 声明

接口类型的定义类似于类的定义，语法格式如下。

```java
public interface 接口名{
    //接口成员
}
```

- 定义接口使用interface修饰符

- 接口的访问权限：public或包访权限(package-access缺省)

- ⼀个接⼝可以继承其它接⼝——称为⽗接⼝，并且接⼝可以多继承。它将继承⽗接⼝中声明的常量和抽象⽅法。

- 成员列表中的成员变量声明` [public] [static] [final] 数据类型 变量名 = 常量; `即接⼝中成员变量默认都是 `public` 、 `static` 、 `final `的，因此 `public static final `可以省略。

- 成员列表中的成员⽅法声明 `public abstract 返回值类型 方法名(参数列表); `即接⼝中的⽅法默认都是

  `public`、`abstract`的，因此`public abstract`可以省略。

#### 实现

使用接口要通过子类，子类通过`implements`关键字实现接口。实现接口的语法格式如下：

```java
public 类名 implements 接口名{
    //实现抽象方法
    //声明普通方法
    //声明成员变量
}
```

- 实现接口使用`implements`关键字
- 一个类可以实现多个接口，各接口之间用逗号分隔
- 实现接口的类必须实现接口中定义的所有抽象方法，即使类中不使用某个抽象方法也必须实现它，通常用空方法体实现子类不需要的抽象方法，如果抽象方法有返回值，可返回默认值。否则必须定义为抽象类。
- 接⼝的实现类允许包含普通⽅法。
- 在实现抽象⽅法时需要指定public权限，否则会产⽣编译错误。
- 接⼝中不允许有构造⽅法。
- 接⼝之间可以通过`extends`实现继承关系，⼀个接⼝可以继承多个接⼝，但接⼝不能继承类。
- 若⼀个类在继承⽗类的同时⼜实现了多个接⼝， `extends`必须位于`implements`之前。

#### 新特性

##### `JDK8.0`

在`JDK8.0`中`default`关键字可用于在接口中修饰方法， `default`修饰的方法可以有具体实现，也只能在接口中实现，`default`修饰的方法可以被重写

在`JDK8.0`中还可以有`static`修饰的方法，称为静态方法，类方法可以直接使用`接口名.方法名`调用，不能被继承

##### `JDK9.0`

在`JDK9.0`中新增`private`方法，声明只能在本接口中使用的方法

### 抽象类与接口的区别

1. 多继承：子类只能继承⼀个直接抽象类；子类可以实现多个接口
2. 实现：子类使用extends继承抽象类；实现类通过implements实现接口
3. 成员：抽象类中可以有实例成员、静态成员、抽象方法，抽象类中的成员⽅法不能⽤default关键字修饰；接口中只有常量、抽象方法，`JDK8.0`之后新增static和default方法，`JDK9.0`之后新增private方法
4. 成员变量修饰符： 抽象类可以定义变量，也可定义常量；接⼝中只能定义常量（public static final修饰的常量）
5. ⼦类实现：⼦类在实现抽象⽅法时不允许缩⼩访问权限；实现类在实现抽象⽅法时必须指定public权限
6. 构造函数：抽象类可以有构造函数；接⼝中不能定义构造函数
7. 最⾼层：类的最⾼层是Object；接⼝没有最⾼层
8. 相同点：两者都不能实例化；都是引⽤类型；都可以包含抽象⽅法

# 内部类

### 成员内部类

成员内部类看起来像是外部类的一个成员，所以内部类可以拥有private、public等访问权限修饰符修饰；也可以用static来修饰。成员内部类分为：

1. 静态成员内部类：使用static修饰类
2. ⾮静态成员内部类：未⽤static修饰类，在没有说明是静态成员内部类时，默认成员内部类指的就是⾮静态成员内部类；

注：只有成员内部类才能加static变成静态内部类。

#### 静态成员内部类

- 静态成员内部类的创建是不需要依赖于外围类的对象
- 静态成员内部类不能使⽤任何外围类的⾮static成员变量和⽅法
- 创建对象的⽅式： `外部类.内部类 变量名 = new 外部类.内部类();`

#### 非静态成员内部类

- 成员内部类访问外部类的信息：

  - 非静态成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括 private 成员和静态成员）。

  - 当非静态成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：

    `外部类.this.成员变量 或 外部类.this.成员方法`

- 创建⾮静态内部类对象

  成员内部类是依附外部类而存在的，所以要创建成员内部类的对象，前提是必须存在一个外部类的对象。

  ```java
  public static void main(String[] args) {
  	Outer outer = new Outer();
  	Inner2 inner2 = outer.new Inner2();
  }
  ```

- 外部类访问成员内部类信息

  外部类也可以访问内部类的所有成员变量和方法（包括private），但外部类想访问成员内部类的成员，必

  须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问

#### 内部类的继承

内部类和其他普通类一样，同样可以被继承，这样给本来就十分灵活的内部类增加了更好的结构性和代码复用性。只是内部类的继承和普通类有一些不同之处，是在使用时需要多加注意的。因为内部类在创建时需要外部类的引用，所以在内部类的继承上也需要外部类的协助。

首先在继承语句extends处，注意命名空间，需要加上外围类名，才能对应上正确的内部类。其次是构造对象上，这里需要自己写一个接受外围类引用的构造器，来给导出类提供创建对象的基本环境。

```java
class WithInner{
	class Inner{
	}
}
public class Test3 extends 	WithInner.Inner{
	Test3(WithInner wi){
		wi.super();
	}
	public static void main(String[] args){
		WithInner wi = new WithInner();
		test3 t3 = new test3(wi);
	}
}
```

### 局部内部类

局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。

一个类可以有多个内部类，内部类可以实现接口和继承类，内部类可以解决java类单继承的问题，因为内部类和外部类可以互相访问，包括private 成员。

1. 外部类访问内部类的实例成员，需要先创建内部类对象
2. 内部类访问外部类的实例成员:`外部类名.this.属性;`
3. `外部类对象.new 内部类()`/`new 外部类.内部类()`
4. 内部类的类型：外部类.内部类
5. static内部类不可以直接访问 non-static (⽅法)、成员,创建静态内部类的⽅式:`外部类.内部类 变量名 = new 外部类.内部类;`
6. 外部类的修饰符：`public` `package-access` `abstract` `final`，`abstract` `final`不能同时出现
7. 成员内部类属于外部类的⼀部分，可以使⽤所有修饰符

### 匿名内部类

匿名内部类的格式：

```java
new 抽象类/接口([参数列表]){
	@Override
	重写父类/接口的方法;
}
```

匿名内部类本质上是一个没有名字的子类对象、或者接口的实现类对象。

需要注意的是，匿名内部类在编写代码时没有名字，编译后系统会为自动为匿名内部类生产字节码，字节码的名称会以`外部类$1.class`的方法命名

**匿名内部类的作用：简化了创建子类对象、实现类对象的书写格式。**

- 匿名类是没有明确的名称的类
- 匿名类不能有访问修饰符，在⽅法的内部，对外隐藏。不能是`static`，`final`类
- 匿名类没有类名，没有构造⽅法，匿名类不能定义接⼝，不能定义静态块，静态⽅法，静态变量
- 匿名类可以访问类中的成员，不能访问⽅法中的变量，除⾮是`final`的
- 匿名类⼀般是实现接⼝，继承抽象类，相当于实现、继承了这个接⼝、类

#### ⭐Lambda表达式